;;;; Functions used in parsing the programming language
;;;; used for program checking.

(defpackage #:parser
  (:use #:common-lisp #:cl-ppcre #:sb-gray))
(in-package #:parser)

;;; ******************************************
;;; Constants
;;; ******************************************

(defconstant var-regex "[a-zA-Z](?:\\d|\\w)*"
  "Regex that represents a valid variable name")
(defconstant reserved-keywords "true|false|if|else|while|T|F"
  "Keywords reserved to the parsed language that a user may not use to define varibales")
(defconstant usage-message
  "usage: program-checker <precondition> <program> <postcondition> [<invariants>] [<variants>]"
  "Message displayed when running the program from the command line if an incorrect number of arguments is passed")
(defconstant error-message
  "The program is not valid. Please verify the syntax and try again."
  "Error displayed if there is a syntax error with the given program")
(defconstant inv-var-error "The numbers of invariants and variants don't match. Please ensure to input equal numbers of each."
  "Error displayed when the numbers of invariants and variants don't match")
(defconstant math-operators '(#\+ #\- #\*)
  "Operators used in mathematical operations for expressions")

;;; ******************************************
;;; Global Variables
;;; ******************************************

(defparameter *invariants* '()
  "List of invariants for the input program. Used for determining partial correctness proofs")
(defparameter *variants* '()
  "List of variants for the input program. Used for determining total corectness proofs ")
(defparameter *partial-proofs* '()
  "Proofs for partial correctness generated by this program")
(defparameter *total-proofs* '()
  "Proofs for total correctness generated by this program")

;;; ******************************************
;;; Data structures
;;; ******************************************

;;; x = y;
(defstruct command var expression)
;;; if boolean { ... } else { ... }
(defstruct if-command boolean then-command-list else-command-list)
;;; while boolean { ... }
(defstruct while-command boolean command-list)

;;; ******************************************
;;; Helper functions
;;; ******************************************

(defun char-eq (char1 char2)
  "Helper function for checking if two chars are equal with the
possibility of char1 or char2 being nil. Returns true if they are equal,
false otherwise"
  (and  
   (not
    (or (null char1) (null char2)))
   (char= char1 char2)))

(defun match (regex input)
  "Matches input to regex. Returns the input string if they match,
nil if they don't"
  (multiple-value-bind (start end)
      (scan regex input)
    (if (or (null start) (null end))
	nil ; The input didn't match the regex
	(and
	 (= 0 start)
	 (= (length input) end)))))

(defun read-while (stream regex)
  "Reads the stream one character at a time as long as the next character
being read matches regex. Returns the characters that were read"
  (format nil "~{~a~}"
	  (loop
	     for char = (peek-char nil stream nil)
	     while (match regex (format nil "~a" char))
	     while (not (null char))
	     do (read-char stream nil)
	     collect char)))

(defun parse-int (stream)
  "Parses an integer from the stream. Returns the integer as a string
if it succeeds, nil otherwise"
  (let ((chars (read-while stream "[\\d-]")))
    (if (match "-?\\d+" chars)
	chars)))

(defun parse-var (stream)
  "Parses a variable identifier from stream. Returns the identifier
as a string if it succeeds, nil otherwise"
  (let ((chars (read-while stream "[\\w\\d]")))
    (if (and
	 (match var-regex  chars)
	 (not (match reserved-keywords  chars)))
	chars)))

(defun parse-left-brace (stream)
  "Parses a left curly brace from the stream. Returns T if
it successfully parsed it, nil otherwise"
  (match "\\s*{\\s*" (read-while stream "[{\\s]")))

(defun parse-right-brace (stream)
  "Parses a right curly brace from the stream. Returns T if
it successfully parsed it, nil otherwise"
  ;; This is implemented differently from parse-left-brace
  ;; because it is possible to have two } in a row, as opposed
  ;; to {
  (and (read-while stream "\\s")
       (char-eq (read-char stream nil) #\})
       (read-while stream "\\s")))

;;; ******************************************
;;; Expression parsing functions
;;; ******************************************

(defun parse-math-expression (stream)
  "Parses the operator and the second operand
of a mathematical expression from stream. Returns them as a
formatted string, nil otherwise"
  (let ((char (read-char stream nil)) ; Read the first char
	(result ""))
    (if (and (member char math-operators) ; Check that it's an operator
	     (read-while stream "\\s")
	     (setf result (parse-expression stream))) ; Parse an expression
	(format nil "~a ~a" char result))))

(defun parse-complex-expression (stream)
  "Parses a multi-part expression. Returns it as a
formatted string, nil otherwise"
  ;; Save the current position of the stream
  (let ((stream-pos (stream-file-position stream))
	(expr-result "")
	(math-result ""))
    ;; Try to read the expression as a mathematical operation
    (if (and
	 (setf expr-result (parse-expression stream))
	 (read-while stream "\\s")
	 (setf math-result (parse-math-expression stream)))
	
	(format nil "~a ~a" expr-result math-result)
	
	;; Else, try to read the expression as a negation
	(progn
	  ;; Restore the stream to its original position
	  (stream-file-position stream stream-pos)
	  (if (and
	       (char-eq (read-char stream nil) #\-)
	       (setf expr-result (parse-expression stream)))
	      (format nil "-~a" expr-result))))))

(defun parse-parenthesized-expression (stream)
  "Parses an expression contained between parentheses. Returns it as a
formatted string, nil otherwise"
  (let ((result ""))
    (if (and
	 (char-eq (read-char stream nil) #\()
	 (read-while stream "\\s")
	 (setf result (parse-complex-expression stream))
	 (read-while stream "\\s")
	 (char-eq (read-char stream nil) #\)))
	(format nil "(~a)" result))))

(defun parse-expression (stream)
  "Parses a top-level expression. Follows the BNF notation
found in chapter 4 of the course book.
E ::= n | x | (-E) | (E + E) | (E - E) | (E * E)
Returns it as a formatted string, nil otherwise"
  (let ((char (format nil "~a" (peek-char nil stream nil))))
    (cond
      ((match "[\\d-]" char) (parse-int stream))
      ((match "\\w" char) (parse-var stream))
      ((match "\\(" char) (parse-parenthesized-expression stream)))))

;;; ******************************************
;;; Boolean parsing functions
;;; ******************************************

(defun parse-compound-boolean (stream)
  "Parses the boolean operator and the second boolean operand.
Returns them as a formatted string, nil otherwise"
  (let ((char (read-char stream nil)))
    ;; If it reads &, directly attempt to read the next token
    ;; as a boolean
    (cond ((char-eq char #\&)
	   (read-while stream "\\s")
	   (format nil "/~a ~a" #\\ (parse-boolean stream)))
	  ;; If it reads |, parse another | then parse an expression
	  ((and (char-eq char #\|)
		(char-eq (read-char stream nil) #\|))
	   (read-while stream "\\s")
	   (format nil "~a/ ~a" #\\ (parse-boolean stream))))))

(defun parse-complex-boolean (stream)
  "Parses a multi-part boolean. This takes care of any comparison
between two booleans or expressions. Returns it as a
formatted string, nil otherwise"
  (let ((char (peek-char nil stream nil)))
    ;; First attempt to read the boolean as a negation
    (if (char-eq char #\!)
	(progn
	  (read-char stream nil)
	  (format nil "~a~a" #\~ (parse-boolean stream)))
	;; If not, save the position of the stream for look-ahead
	(let ((stream-pos (stream-file-position stream))
	      (op-char nil)
	      (result ""))
	  ;; Now try parsing the boolean as a comparison between expressions
	  (if (setf result (parse-expression stream))
	      (progn
		(read-while stream "\\s")
		(setf op-char (read-char stream nil))
		;; Check for < and >
		(if
		 (and (or (char-eq op-char #\<) (char-eq op-char #\>))
		       (not (char-eq (peek-char nil stream nil) #\=)))
		  (progn
		    (read-while stream "\\s")
		    (format nil "~a ~a ~a"
			    result op-char (parse-expression stream)))
		  ;; Else check for <=, >=, !=, or ==
		  (let ((next-char (read-char stream nil)))
		    (read-while stream "\\s")
		    (cond
		      ((and (char-eq op-char #\<) (char-eq next-char #\=))
		       (format nil "~a <= ~a"
			       result (parse-expression stream)))
		      ((and (char-eq op-char #\>) (char-eq next-char #\=))
		       (format nil "~a >= ~a"
			       result (parse-expression stream)))
		      ((and (char-eq op-char #\!) (char-eq next-char #\=))
		       (format nil "~a != ~a"
			       result (parse-expression stream)))
		      ((and (char-eq op-char #\=) (char-eq next-char #\=))
		       (format nil "~a = ~a"
			       result (parse-expression stream)))))))
	      ;; If it couldn't parse as a comparison between expressions,
	      ;; then try parsing as a comparison between booleans
	      (progn
		;; Restore the stream at its original position
		(stream-file-position stream stream-pos)
		(if (and (setf result (parse-boolean stream))
			 (read-while stream "\\s"))
		    (format nil "~a ~a"
			    result (parse-compound-boolean stream)))))))))

(defun parse-boolean (stream)
  "Parses a top-level boolean expression. Follows an extended version
of the BNF notation found in chapter 4 of the course book.
B ::= true | false | (!B) | (B & B) | (B || B)
    | (E < E) | (E > E) | (E <= E) | (E >= E) | (E == E) | (E != E)
Returns it as a formatted string, nil otherwise"
  (if (char-eq (peek-char nil stream nil) #\()
      (let ((result ""))
	;; Try parsing as a complex boolean
	(if (and
	     (char-eq (read-char stream nil) #\()
	     (read-while stream "\\s")
	     (setf result (parse-complex-boolean stream))
	     (read-while stream "\\s")
	     (char-eq (read-char stream nil) #\)))
	    (format nil "(~a)" result)))
      ;; Otherwise, try parsing as the primitives true or false, and return
      ;; tautology (T) or contradiction (F), respectively
      (let ((value (read-while stream "[truefals]")))
	(cond ((match "true" value) "T")
	      ((match "false" value) "F")))))

;;; ******************************************
;;; Command parsing functions
;;; ******************************************

;;; Command parsing functions return command data structures
;;; corresponding to the type of command being parsed.

(defun parse-assignment (stream)
  "Parses an assignment statement of the following form:
var = value
Returns a command data structure representing the parsed code
if it succeeds, otherwise returns nil"
  (let ((comm (make-command)))
    (if
     (and
      (setf (command-var comm) (parse-var stream))
      (read-while stream "\\s")
      (char-eq (read-char stream nil) #\=)
      (read-while stream "\\s")
      (setf (command-expression comm) (parse-expression stream)))
     comm)))

(defun parse-if (stream)
  "Parses an if statement of the following form:
if boolean { ... } else { ... }
Returns an if-command data structure representing the parsed code
if it succeeds, otherwise returns nil"
  (let ((chars (progn
		 ;; Read "if" from the stream
		 (format nil "~a~a"
			 (read-char stream nil)
			 (read-char stream nil))))
	(comm (make-if-command)))
    (if (and (match "if" chars)
	     (read-while stream "\\s")
	     ;; Parse the boolean
	     (setf (if-command-boolean comm) (parse-boolean stream))
	     (parse-left-brace stream)
	     ;; Parse the "then" command list
	     (setf (if-command-then-command-list comm)
		   (parse-command-list stream))
	     (parse-right-brace stream)
	     (match "else" (read-while stream "[else]"))
	     (parse-left-brace stream)
	     ;; Parse the "else" command list
	     (setf (if-command-else-command-list comm)
		   (parse-command-list stream))
	     (parse-right-brace stream))
	comm)))

(defun parse-while (stream)
  "Parses a while statement of the following form:
while boolean { ... }
Returns a while-command data structure representing the parsed code
if it succeeds, otherwise returns nil"
  (let ((chars (read-while stream "[while]"))
	(comm (make-while-command)))
    (if (and (match "while" chars)
	     (read-while stream "\\s")
	     ;; Parse the boolean
	     (setf (while-command-boolean comm) (parse-boolean stream))
	     (parse-left-brace stream)
	     ;; Parse the inner command list
	     (setf (while-command-command-list comm)
		   (parse-command-list stream))
	     (parse-right-brace stream))
	comm)))

(defun parse-command (stream)
  "Top-level parsing function for parsing different commands.
Differentiates between an assignment, an if statement, and a
while statement. Returns the data structure corresponding
data structure if it succeeds, otherwise returns nil"
  ;; Read the first few characters and then reset the stream
  ;; to know how to parse the commands
  (let ((stream-pos (stream-file-position stream))
	(chars (read-while stream "[\\w\\d]")))
    (stream-file-position stream stream-pos)
    (cond
      ((match "if" chars) (parse-if stream))
      ((match "while" chars) (parse-while stream))
      (t (parse-assignment stream)))))

(defun parse-command-list (stream)
  "Parses a list of commands separated by semi-colons. The final
command can optionally be followed by a semi-colon. If it succeeds,
returns a list of data structures, each corresponding to a command
that was read"
  (loop
     for comm = (parse-command stream)
     for char = (progn (read-while stream "\\s")
		       (peek-char nil stream nil))
     for is-semi-colon = (char-eq char #\;)
     for is-command = (command-p comm)
     for continue = t
       
     while (not (null comm)) ; As long as commands are valid
     collect comm
       
     ;; If end of stream is reached, stop parsing
     do (if is-command
	    (if is-semi-colon
		(read-char stream nil)
		(setf continue nil)))
       
     do (read-while stream "\\s")
     while continue))

;;; ******************************************
;;; Command bubbling functions
;;; ******************************************

;;; These functions are used to bubble up through the commands
;;; from last to first as seen in the course. They manipulate
;;; the commands to output the formulas that will be needed to
;;; prove the validity of the program

(defun bubble-assignment (command prop-cond)
  "Applies the assignment rule using command to the given propositional
logic formula, prop-cond"
  ;; Replace any occurrences of the variable in prop-cond
  ;; with its assigned value
  (regex-replace-all 
   (concatenate 'string
		"([^\\w]|[\\s]|^)"
		(command-var command)
		"([^\\w]|[\\s]|$)")
   prop-cond
   (concatenate 'string
		"\\{1}"
		(command-expression command)
		"\\{2}")))

(defun bubble-if (command prop-cond &optional (total-correctness nil))
  "Applies the if-statement rules using command to the given
propositional logic formula, prop-cond. If generating formulas
for total correctness, then total-correctness must be set to T"
  ;; Evaluate the "then" and "else" command lists such that each section
  ;; should eventually satisfy prop-cond
  (let ((a1 (bubble-commands
	     (if-command-then-command-list command)
	     prop-cond
	     total-correctness))
	(a2 (bubble-commands
	     (if-command-else-command-list command)
	     prop-cond
	     total-correctness))
	(bool (if-command-boolean command)))
    (format nil "(~a -> ~a) /~a (~a~a -> ~a)" bool a1 #\\ #\~ bool a2)))

(defun bubble-partial-while (command prop-cond)
  "Applies the while-statement rules using command to the given
propositional logic formula prop-cond, in the context of partial
correctness."
  (let ((invariant (pop *invariants*)))  
    (if (null invariant)
	(setf invariant "inv")) ; If no invariant found, default to "inv"
    (let ((implied (bubble-commands
		    (while-command-command-list command)
		    invariant))
	  (bool (while-command-boolean command)))
      ;; As seen in the course notes:
      ;; (| A /\ ~B |)  Partial-while
      ;; (| A' |)       Implied
      ;; Therefore
      ;; (A /\ ~B) -> A'
      (push (format nil "(~a /~a ~a~a) -> (~a)"
		    invariant #\\ #\~ bool prop-cond) *partial-proofs*)
      ;; As seen in the course notes:
      ;; (| A /\ B |)  Invariant hypothesis and guard
      ;; (| A1 |)      Implied
      ;; (A /\ B) -> A1
      (push (format nil "(~a /~a ~a) -> (~a)"
		    invariant #\\ bool implied) *partial-proofs*)
      invariant)))

(defun bubble-total-while (command prop-cond)
  "Applies the while-statement rules using command to the given
propositional logic formula prop-cond, in the context of total
correctness."  
  (let ((invariant (pop *invariants*))
	(variant (pop *variants*)))
    (if (null invariant)
	(setf invariant "inv")) ; If no invariant found, default to "inv"
    (if (null variant)
	(setf variant "var")) ; If no variant found, default to "var"
    (let ((implied (bubble-commands
		    (while-command-command-list command)
		    (format nil "~a /~a 0 <= ~a < init"
			    invariant #\\ variant)
		    t))
	  (bool (while-command-boolean command)))
      ;; As seen in the course notes:
      ;; (| A /\ ~B |)  Partial-while
      ;; (| A' |)       Implied
      ;; Therefore
      ;; (A /\ ~B) -> A'
      (push (format nil "(~a /~a ~a~a) -> (~a)"
		    invariant #\\ #\~ bool prop-cond) *total-proofs*)
      ;; As seen in the course notes:
      ;; (| A /\ B /\ 0 <= E = E0|)  Invariant hypothesis and guard
      ;; (| A1 /\ 0 <= E1 < E0 |)    Implied
      ;; (A /\ B /\ 0 <= E = E0) -> (A1 /\ 0 <= E1 < E0)
      (push (format nil "(~a /~a ~a /~a 0 <= ~a = init) -> (~a)"
		    invariant #\\ bool #\\ variant implied) *total-proofs*)
      (format nil "~a /~a 0 <= ~a" invariant #\\ variant))))

(defun bubble-commands (commands postcondition
			&optional (total-correctness nil))
  "Bubbles up through a list of command from last to first
and applies the appropriate rules for proving either partial
or total correctness for the program represented by the list,
commands. Use postcondition to set the postcondition of the program.
Set total-correctness to T if total correctness formulas are desired"
  (if (null commands)
      nil
      ;; Bubble through each command, updating the current propositional
      ;; logic condition, initiating it to the postcondition
      (let ((reverse-commands (reverse commands))
	    (current-prop-condition postcondition))
	(loop for command in reverse-commands
	   if (command-p command)
	   do (setf current-prop-condition
		    (bubble-assignment command current-prop-condition))
	   if (if-command-p command)
	   do (setf current-prop-condition
		    (bubble-if
		     command
		     current-prop-condition
		     total-correctness))
	   if (while-command-p command)
	   do (progn
		(setf current-prop-condition
		      (if (null total-correctness)
			  (bubble-partial-while
			   command current-prop-condition)
			  (bubble-total-while
			   command current-prop-condition)))))
	current-prop-condition)))

;;; ******************************************
;;; Main functions
;;; ******************************************

(defun build-parse-tree (input)
  "Reads through input and parses it following the BNF notation
shown in the course book. Outputs a list of data structures representing
the parsed code. If it fails, returns nil"
  (let* ((stream (make-string-input-stream input)))
    (read-while stream "\\s")
    (let ((comm-list (parse-command-list stream)))
      (if (and (not (null comm-list))
	       (null (read-char stream nil)))
	  comm-list))))

(defun check-program (precondition program postcondition invariants variants)
  "Generates propositional logic formulas needed to prove the validity
of program given precondition and postcondition. Outputs two sets of
formulas: those needed for proving partial correctness and those needed
for proving total correctness. If there is a syntax error in the program,
returns nil. If the program contains while loops, invariants and variants
are each expected to be a list of invariants and variants following the
same order as the textual order of the while loops. Otherwise, they can
be empty lists. The formulas are returned as a string"
  (setf *partial-proofs* '())
  (setf *total-proofs* '())
  (setf *invariants* (reverse invariants))
  (setf *variants* (reverse variants))
  ;; Parse the program first
  (let* ((parse-tree (build-parse-tree program))
	 (invariants-copy (copy-list *invariants*))
	 ;; Generate the partial correctness formulas
	 (partial-correctness 
	  (bubble-commands parse-tree
			   (format nil "(~a)" postcondition))))
    (setf *invariants* (copy-list invariants-copy)) ; Reset the invariants
    ;; Generate the total correctness formulas
    (let ((total-correctness 
	   (bubble-commands parse-tree
			    (format nil "(~a)" postcondition) t)))
      (if (or (null partial-correctness) (null total-correctness))
	  nil
	  (format nil "Partial correctness proofs:~%(~a) -> ~a~{~%~a~}~%~%Total correctness proofs:~%(~a) -> ~a~{~%~a~}"
		  precondition partial-correctness *partial-proofs*
		  precondition total-correctness *total-proofs*)))))

(defun main (argv)
  "The main entry point of the program. Parses the given arguments
into a precondition, a program, a postcondition, a list of invariants,
and a list of variants. It then attempts to generate formulas for
proving the validity of the program. If it fails, it outputs
an error message explaining what went wrong"
  (if (not (>= (length argv) 4))
      (progn (write-line usage-message)
	     (sb-ext:exit))
      (let ((precondition (nth 1 argv))
	    (program (nth 2 argv))
	    (postcondition (nth 3 argv))
	    (inv-var-length (- (length argv) 4)))
	;; Make sure that the total number of invariants and variants
	;; is even
	(if (not (= (mod inv-var-length 2) 0))
	    (write-line inv-var-error)
	    (let* ((inv-length (/ inv-var-length 2))
		   (invariants (subseq argv 4 (+ inv-length 4)))
		   (variants (subseq argv (+ inv-length 4) (length argv)))
		   ;; Run the program
		   (result (check-program
			    precondition
			    program
			    postcondition
			    invariants
			    variants)))
	      (if (null result)
		  (write-line error-message)
		  (write-line result))
	      (sb-ext:exit))))))
